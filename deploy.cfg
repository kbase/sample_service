[SampleService]
kbase-endpoint = {{ kbase_endpoint }}
job-service-url = {{ job_service_url }}
workspace-url = {{ workspace_url }}
shock-url = {{ shock_url }}
handle-service-url = {{ handle_url }}
srv-wiz-url = {{ srv_wiz_url }}
njsw-url = {{ njsw_url }}
auth-service-url = {{ auth_service_url }}
auth-service-url-allow-insecure = {{ auth_service_url_allow_insecure }}
scratch = /kb/module/work/tmp

# Location and credentials for the KBase Authentication service.
# auth-root-url is the KBase auth service root url, e.g. https://kbase.us/services/auth
# auth-token is any valid auth token for the sample service to use for user lookups. A service
# token is recommended.

{% if "appdev" in kbase_endpoint %}
auth-root-url={{ appdev_auth_root_url }}
auth-token={{ appdev_auth_token}}
{% else %}
auth-root-url={{ auth_root_url }}
auth-token={{ auth_token}}
{% endif %}


# Location and credentials for the ArangoDB instance in which to store data.
# The DB is expected to be shared with the KBase relation engine.

{% if "appdev" in kbase_endpoint %}
arango-url={{ appdev_arango_url }}
{% else %}
arango-url={{ arango_url }}
{% endif %}

arango-db = {{ arango_db }}
arango-user = {{ arango_user}}
arango-pwd = {{ arango_pwd}}

# Collection names for the sample service to use. These are configurable because:
# 1) The collection names might collide with Relation Engine collection names if hard coded into
#    the service as per normal practice
# 2) The service should not create collections on start up to allow for admins to do so instead,
#    so the admins can set up sharding correctly, which cannot be changed after collection
#    creation.

sample-collection = {{ sample_collection }}
version-collection = {{ version_collection }}
version-edge-collection = {{ version_edge_collection }}
node-collection = {{ node_collection }}
node-edge-collection = {{ node_edge_collection }}
schema-collection = {{ schema_collection }}

#########################################
#
# Metadata validators
#
#########################################

# The metadata_validator_configs key can be used to add a multiline block specifying validators
# for metadata keys. The configuration parameters take the following form:
#
# metaval-<key>-module = <module name>
# metaval-<key>-callable_builder = <validation callable builder name>
# metaval-<key>-param-<X> = <Y>
#
# where:
#
# <key> is the name of the metadata key to be validated. Any extact match to this string
# in the controlled metadata will trigger the validator.
#
# <module name> is the name of the module containing the validation callable builder, e.g. 
# SampleService.core.validators.builtin
#
# <validation callable builder name> is the name of the function within the module that
# will build a validation callable, e.g. noop.
# See the readme for a description of the required parameters and behavior of the callable.
#
# <X> and <Y> are parameters used to configure the callable, where X is the key and V with value.
# These will be provided to the callable builder function on startup.
#
# For example, for a simple string length checker for the common_name metadata key:
# metaval-common_name-module = SampleService.core.validators.builtin
# metaval-common_name-callable_builder = string_length
# metaval-common_name-param-max_len = 50

{{ metadata_validator_configs }}