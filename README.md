# SampleService


Build status (master):
[![Build Status](https://travis-ci.org/kbaseIncubator/sample_service.svg?branch=master)](https://travis-ci.org/kbaseIncubator/sample_service)
[![Coverage Status](https://coveralls.io/repos/github/kbaseIncubator/sample_service/badge.svg?branch=master)](https://coveralls.io/github/kbaseIncubator/sample_service?branch=master)

This is a [KBase](https://kbase.us) module generated by the [KBase Software Development Kit (SDK)](https://github.com/kbase/kb_sdk).

You will need to have the SDK installed to use this module. [Learn more about the SDK and how to use it](https://kbase.github.io/kb_sdk_docs/).

You can also learn more about the apps implemented in this module from its [catalog page](https://narrative.kbase.us/#catalog/modules/SampleService) or its [spec file](SampleService.spec).

# Description

The Sample Service stores information regarding experimental samples taken from the environment.
It has Access Control Lists for each sample, supports subsample trees, and modular metadata
validation.

The SDK API specification for the service is contained in the `SampleService.spec` file. An indexed
interactive version is
[also available](http://htmlpreview.github.io/?https://github.com/kbaseIncubator/sample_service/blob/master/SampleService.html).

# Setup and test

The Sample Service requires ArangoDB 3.5.1+ with RocksDB as the storage engine.

To run tests, MongoDB 3.6+ and the KBase Jars file repo are also required.

See `.travis.yml` for an example of how to set up tests, including creating a `test.cfg` file
from the `test/test.cfg.example` file.

Once the dependencies are installed, run:

```
pipenv install --dev
pipenv shell
make test-sdkless
```

`kb-sdk test` does not currently pass. 


# Installation from another module

To use this code in another SDK module, call `kb-sdk install SampleService` in the other module's root directory.

# Help

You may find the answers to your questions in our [FAQ](https://kbase.github.io/kb_sdk_docs/references/questions_and_answers.html) or [Troubleshooting Guide](https://kbase.github.io/kb_sdk_docs/references/troubleshooting.html).

# API Error codes

Error messages returned from the API may be general errors without a specific structure to
the error string or messages that have error codes embedded in the error string. The latter
*usually* indicate that the user/client has sent bad input, while the former indicate a server
error. A message with an error code has the following structure:

```
Sample service error code <error code> <error type>: <message>
```

There is a 1:1 mapping from error code to error type; error type is simply a more readable
version of the error code. The error type **may change** for an error code, but the error code
for a specfic error will not.

The current error codes are:
```
20000 Unauthorized
30000 Missing input parameter
30001 Illegal input parameter
30010 Metadata validation failed
40000 Concurrency violation
50000 No such user
50010 No such sample
50020 No such sample version
60000 Unsupported operation
```

# Metadata validation

Each node in the sample tree accepted by the `create_sample` method may contain controlled and
user metadata. User metadata is not validated other than very basic size checks, while controlled
metadata is validated based on configured validation rules.

Validators are modular and can be added to the service via configuration without changing the
service core code. Validators are assigned to metadata keys in a 1:M relationship - that is, each
metadata key has one validator assigned, but multiple keys may use the same validator, possibly
with different parameters for the validator.

Sample metadata has the following structure (also see the service spec file):

```
{"metadata_key_1: {"metadata_value_key_1_1": "metadata_value_1_1",
                                        ...
                   "metadata_value_key_1_N": "metadata_value_1_N",
                   },
                      ...
 "metadata_key_N: {"metadata_value_key_N_1": "metadata_value_N_1",
                                        ...
                   "metadata_value_key_N_N": "metadata_value_N_N",
                   }
}
```
Metadata values are primitives: a string, float, integer, or boolean.

A simple example:
```
{"temperature": {"measurement": 1.0,
                 "units": "Kelvin"
                 },
 "location": {"name": "Castle Geyser",
              "lat": 44.463816,
              "long": -110.836471
              }
}
```

In this case, a validator would need to be assigned to the `temperature` and `location`
metadata keys. Validators are `python` callables that accept the value of the key as the only
argument. E.g. in the case of the `temperature` key, the argument to the function would be:

```
{"measurement": 1.0,
 "units": "Kelvin"
 }
```

If the metadata is incorrect, the validator should return an error message as a string. Otherwise
it should return `None` unless the validator cannot validate the metadata due to some
uncontrollable error (e.g. it can't connect to an external server after a reasonable timeout),
in which case it should throw an exception.

[TODO redo validator configuration to pull a yaml file from a url rather than using catalog
 params and document here]

 Validators are built by the builder function specified in the configuration. The builder is
 passed any parameters specified in the configuration as a string -> string mapping. This allows
 the builder function to set up any necessary state for the validator before returning the
 validator for use. Examine the validators in `SampleService.core.validators.builtin` for examples.
 A very simple example might be:

 ```python
 def enum_builder(params: Dict[str, str]
        ) -> Callable[[Dict[str, Union[float, int, bool, str]]], Optional[str]]:
    # should handle errors better here
    enums = {e.strip() for e in d['enums'].split(',')}
    key = d['key']

    def validate_enum(value: Dict[str, Union[float, int, bool, str]]) -> Optional[str]:
        if value.get(key) not in enums:
            return f'Illegal value for key {key}: {value.get(key)}'
        return None

    return validate_enum
```


